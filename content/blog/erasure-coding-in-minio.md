---
title: "MinIO 的纠删码原理与应用"
description: 最近在用MinIO，查阅了很多文档、相关文章，让AI总结了后，发出来记录一下。可能会有错，有朋友发现了，还望赐教！
date: 2025-02-12
image: /images/blog/minio.png
minRead: 10
author:
  name: Qhbee
  avatar:
    src: /avatar.jpg
    alt: Qhbee
---

在分布式存储系统中，数据的可靠性和可用性是至关重要的。MinIO作为一种高性能的分布式对象存储系统，采用了纠删码（Erasure Coding）技术来实现数据的高可用性和容错能力。本文将详细介绍MinIO中纠删码的原理、优势以及如何通过配置平衡可用性和存储效率。

## 一、纠删码原理简介

### （一）什么是纠删码

纠删码是一种通过增加冗余信息来提高数据可靠性的技术。它将数据分割成多个数据块，并生成额外的校验块。这些数据块和校验块分散存储在不同的节点上。即使部分节点故障，只要剩余的节点数量满足一定条件，就可以通过校验块重建丢失的数据。

### （二）纠删码与副本机制的区别

-   **副本机制（如Hadoop）** ：数据被完整地复制多份（例如三份），分别存储在不同的节点上。如果某个节点故障，可以通过其他节点上的完整副本恢复数据。
-   **纠删码机制（MinIO）** ：数据被分割成多个数据块，并计算出额外的校验块。这些数据块和校验块分散存储在不同的节点上。即使部分节点故障，只要剩余的节点数量满足一定条件（通常是总节点数的一半以上），就可以通过校验块重建丢失的数据。

### （三）MinIO集群的可靠性设计

在MinIO集群中，数据的可靠性是通过纠删码实现的，而不是通过传统的多副本机制。例如：

-   一个4节点的MinIO集群，只要有2个节点在线，数据就可以被读取；但需要3个节点在线才能写入新数据。
-   一个8节点的MinIO集群，只要有4个节点在线，数据就可以被读取；但需要5个节点在线才能写入新数据。

### （四）为什么MinIO不使用传统副本机制

1. **存储效率更高**：纠删码只需要存储较少的冗余数据，相比多副本机制，存储利用率更高。例如，使用纠删码可能只需要存储50%的冗余数据，而三副本机制需要存储200%的冗余数据。
2. **容错能力更强**：纠删码可以在多个节点同时故障的情况下恢复数据，而传统副本机制通常只能容忍单个副本的故障。
3. **性能优化**：纠删码在分布式存储中可以更好地平衡读写性能，尤其是在大规模集群中。

## 二、Reed-Solomon编码：纠删码的核心算法

Reed-Solomon编码是纠删码中最常用的算法之一，它基于有限域（Galois Field）的数学原理来生成校验块，并通过这些校验块恢复丢失的数据块。以下是Reed-Solomon编码的基本原理和数据恢复过程。

### （一）数据分割与校验块生成

假设我们有一个文件，需要存储在分布式系统中。Reed-Solomon编码的第一步是将文件分割成多个数据块，并生成额外的校验块。具体步骤如下：

1. **数据分割**：将文件分割成`k`个数据块，每个数据块大小相同。
2. **生成校验块**：通过Reed-Solomon编码算法，根据`k`个数据块生成`m`个校验块。最终，总共有`n = k + m`个块。
3. **存储数据和校验块**：将`k`个数据块和`m`个校验块分散存储在不同的存储节点上。

### （二）数据恢复

当需要读取文件时，Reed-Solomon编码可以从存储节点中读取任意`k`个块（数据块或校验块），然后通过解码算法恢复原始文件。即使部分节点（最多`m`个）故障，只要能够读取到`k`个块，就可以恢复数据。

### （三）数学原理

[ECC之Reed-Solomon算法 - 知乎](https://zhuanlan.zhihu.com/p/104306038)

[Reed-Solomon编码简介 - 知乎](https://zhuanlan.zhihu.com/p/351286576)

[Reed-Solomon纠错码(RS码)（里德-所罗门码）_里德所罗门编码-CSDN博客](https://blog.csdn.net/weixin_42388255/article/details/106520370)

### （四）举例说明

假设我们有一个文件，需要存储在5个节点的MinIO集群中。我们可以选择将文件分割成3个数据块（$k=3$），并生成2个校验块（$m=2$），总共5个块（$n=k+m=5$）。

-   **数据分割**：假设原始文件是一个简单的数字序列：1, 2, 3。我们将这个序列分割成3个数据块：

  -   $D_1 = 1$
  -   $D_2 = 2$
  -   $D_3 = 3$

-   **生成校验块**：Reed-Solomon编码算法通过多项式插值来生成校验块。具体步骤如下：

  1.  **选择有限域**：通常使用有限域 $GF(2^w)$，其中 w 是位宽。为了简单起见，这里我们使用 $GF(2^3)$，即 $8$ 元素的有限域（$0$ 到 $7$）。

  2.  **构造多项式**：将数据块作为多项式的系数构造一个多项式。假设多项式为 $P(x) = D_1 + D_2 \cdot x + D_3 \cdot x^2$

  3.  **计算校验块**：在有限域内选择 $m$ 个不同的值（通常为 $0$ 到 $m−1$），计算多项式在这些值上的结果作为校验块。这里我们选择 $x=0$ 和 $x=1$：

  -   $P(0) = 1 + 2 \cdot 0 + 3 \cdot 0^2 = 1$ → 校验块 $P_1 = 1$
  -   $P(1) = 1 + 2 \cdot 1 + 3 \cdot 1^2 = 6$ → 校验块 $P_2 = 6$

  所以，我们得到的 5 个块是：

  -   数据块：$D_1 = 1$, $D_2 = 2$, $D_3 = 3$
  -   校验块：$P_1 = 1$, $P_2 = 6$

-   **数据存储**：将这5个块分别存储在5个节点上：

  -   节点1：$D_1 = 1$
  -   节点2：$D_2 = 2$
  -   节点3：$D_3 = 3$
  -   节点4：$P_1 = 1$
  -   节点5：$P_2 = 6$

-   **数据恢复**：假设节点 1 和节点 2 故障，丢失了 $D_1$ 和 $D_2$ ，但仍然可以从节点 3、4 和 5 中读取 $D_3 = 3$， $P_1 = 1$，$P_2 = 6$。通过解码算法，从 $D_3$, $P_1$ 和$P_2$ 中恢复 $D_1$ 和 $D_2$ ：
  1.  **构造方程组**：

  -   已知 $D_3 = 3$, $P_1 = 1$, $P_2 = 6$
  -   多项式 $P(x) = D_1 + D_2 \cdot x + D_3 \cdot x^2$
  -   代入已知的校验块：

      $$P(0) = D_1 + D_2 \cdot 0 + D_3 \cdot 0^2 = D_1 = 1$$

      $$P(1) = D_1 + D_2 \cdot 1 + D_3 \cdot 1^2 = D_1 + D_2 + D_3 = 6$$

      $$D_3 = 3$$

  2.  **解方程组**：

  -   从 $P(0) = 1$ 可知 $D_1 = 1$
  -   代入 $P(1) = 6$：
      $$1 + D_2 + 3 = 6 \implies D_2 = 2$$

  所以，我们成功地恢复了丢失的数据块：

  -   $D_1 = 1$
  -   $D_2 = 2$

  -   从 $P(0) = 1$ 可知 $D_1 = 1$
  -   代入 $P(1) = 6$：$1 + D_2 + 3 = 6 \rightarrow D_2 = 2$

### （五）Reed-Solomon编码的优势

-   **高容错能力**：即使部分节点故障，只要剩余的块数量满足`k`个，就可以恢复数据。
-   **存储效率**：相比传统的多副本机制，Reed-Solomon编码只需要较少的冗余数据，存储利用率更高。
-   **灵活性**：可以根据需要调整`k`和`m`的值，以平衡可靠性、性能和存储成本。

### （六）Reed-Solomon 编码 VS 汉明码

Reed-Solomon 编码和汉明码（Hamming Code）都是用于错误检测和纠正的编码技术，但它们在设计目标、应用场景和实现方式上有显著的区别。以下是它们的主要区别：

1. **编码原理**
  -   **汉明码**：一种线性纠错码，主要用于检测和纠正单个位错误。它通过添加冗余的校验位来实现错误检测和纠正。汉明码的编码过程相对简单，适用于对计算资源要求较低的场景。
  -   **Reed-Solomon 编码**：一种基于多项式的纠错码，属于非二进制 BCH 码的子类。它通过将数据分割成符号（而非单个位），并生成校验符号来实现错误检测和纠正。可以纠正多个符号错误，而不仅仅是单个位错误。

2. **纠错能力**
  -   **汉明码**：只能检测和纠正单个位错误。如果同时出现多个位错误，汉明码可能无法正确纠正。
  -   **Reed-Solomon 编码**：可以纠正多个符号错误。例如，一个 $(n,k)$ 的 Reed-Solomon 编码可以纠正最多 $2n−k$ 个符号错误。

3. **编码效率**
  -   **汉明码**：编码效率相对较低，因为它需要添加较多的冗余位来纠正单个位错误。汉明码的编码长度 $n$ 和信息长度 $k$ 满足关系 $n=2m−1$，其中 $m$ 是校验位的数量。
  -   **Reed-Solomon 编码**：编码效率较高，因为它通过符号级别的编码减少了冗余信息。Reed-Solomon 编码的编码长度 $n$ 和信息长度 $k$ 满足关系 $n=2m−1$，其中 $m$ 是符号大小（以位为单位）。

4. **实现复杂度**
  -   **汉明码**：实现相对简单，适合对计算资源要求较低的场景。
  -   **Reed-Solomon 编码**：实现相对复杂，需要处理多项式运算和有限域计算。

5. **应用场景**
  -   **汉明码**：由于其简单性，广泛应用于计算机内存、数据压缩和电信系统。它适用于对错误纠正要求较低且计算资源有限的场景。
  -   **Reed-Solomon 编码**：广泛应用于需要高可靠性和高容错能力的场景，如存储设备（CD、DVD）、无线通信、卫星通信、数字电视和二维码。


## 三、MinIO纠删码的应用：平衡可用性和存储率

在MinIO中，通过配置纠删码的参数，可以在数据的可用性和存储效率之间取得平衡。官网图文并茂，已经讲得特别好了，这里就不自己写了。

官网原文：[Erasure Coding — MinIO Object Storage for Linux](https://min.io/docs/minio/linux/operations/concepts/erasure-coding.html)

中文翻译：[MinIO 纠删码 （Erasure Coding）-CSDN博客](https://blog.csdn.net/zhnagruihua/article/details/135700575)

以下是MinIO中纠删码配置的关键参数及其影响。

### （一）关键参数
-   **Erasure Set Size（N）** ：纠删集的大小，表示一个纠删集中包含的总块数（数据块+校验块）。
-   **Data Shards（K）** ：数据块的数量。
-   **Parity Shards（M）** ：校验块的数量，满足`N = K + M`。

### （二）配置影响
-   **存储效率**：较高的`M`值（校验块数量）会增加容错能力，但会降低可用存储空间。较低的`M`值则提供更高的存储利用率，但容错能力较弱。
-   **读写性能**：较高的`M`值会增加数据恢复的计算复杂度，但可以容忍更多的节点故障。较低的`M`值则在读写性能上表现更好，但容错能力有限。

### （三）MinIO的默认配置与推荐
MinIO默认使用`EC:4`配置，即在16个驱动器的纠删集中，有12个数据块和4个校验块。
这种配置提供了较好的平衡，如果需要更高的容错能力，可以增加`M`的值，例如`EC:6`或`EC:8`。但需要注意的是，增加`M`值会降低存储利用率。

### （四）特殊情况：`M = N/2`
当`M`值正好是纠删集大小的一半时，写入操作的最小驱动器数变为`K+1`。这种配置可以防止“脑裂”现象，即网络问题导致纠删集的一半驱动器与另一半隔离的情况。

## 五、总结
MinIO通过纠删码技术实现了高可用性和数据可靠性，而不是通过简单的多副本机制。
Reed-Solomon编码作为纠删码的核心算法，通过将数据分割成多个数据块并生成校验块，能够在部分节点故障的情况下恢复数据。
通过合理配置纠删码的参数，可以在数据的可用性和存储效率之间取得平衡。
在实际部署中，应根据具体需求选择合适的配置，并定期进行监控与维护，以确保MinIO集群的稳定运行。

希望本文对您理解MinIO的纠删码原理与应用有所帮助。如有任何疑问或建议，欢迎在评论区留言交流。
